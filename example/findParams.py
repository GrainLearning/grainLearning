""" Author: Hongyang Cheng <chyalexcheng@gmail>
	 Parameter identification using the particle filter:
	 
	 Probablistic identification of parameters for DEM simulations
	 based on sequential data assimilation. 
	 
	 In this simple example, Monte Carlo simulations are run with 
	 parameter sets generated by Halton sequence. Only the observation
	 data file is needed to be prepared beforehand. The identified values
	 come in the forms of probability density functions if the covariance 
	 is wisely chosen. The names and ranges of parameters have to be in 
	 the same order. Number of simulation steps that output data need to 
	 be the same as the number of observation data.
"""    
	
from tableGenerator import paramsTable
from plotResults import *
import numpy as np
from os import system
from os import listdir
from os import path
import matplotlib.pyplot as plt

#########################################################
##  inputs for parameter identification of DEM models  ##
#########################################################

""" param names: type strings, names of parameters
    param maxs: type tuples, maximums ranges of parameters
    param mins: type tuples, minimums ranges of parameters
    param nSample: type integer, number of sampling points for Monte Carlo simulation
    param thread: type integer, number of thread for each parallel simulation
    param nStep: type integer, number of simulation and observation steps
    param nObs: type integer, number of independent observation points
    param cov: type float, used in covariance matrix of the error terms
    param mcsData: type boolean, whether run parallel DEM simulations or not
"""

# define parameter names and ranges
names = ['E',  'v', 'kr', 'eta', 'mu']
maxs  = [1e11, 0.5,   1.0,  1.0, 60.0]
mins  = [1e7,   .0,    .0,   .0,   .0]

# set number of samples and threads for each parallel Yade session
nSample = 1000; thread = 4
# get number of observation points and steps
obs = np.genfromtxt('obsdata.dat')
nStep = len(obs)
nObs  = len(obs[0])
# give covariance of error terms
cov = 0.3
# whether a Monte Carlo simulation database is available
mcsData = True

####################################
##  run parallel DEM simulations  ##
####################################

## if no available database
if not mcsData:
	# generate parameter table with halton sequence
	paramsTable(names,maxs,mins,nSample,thread)
	# run parallel Yade simulations
	system("yadedaily-batch table.dat mcTriax.py")
else:
	print "Use the existing Monte Carlo simulation database"
	
##########################################
## input files for the particle filter  ##
##########################################

# Monte Carlo simulation data file
fout = file('MCS.dat','w')
for i in xrange(nSample):
   fout.write(str(i+1)+'\n')
   data = np.load('mcSimulations/'+str(i)+'.npy').item()
   for j in xrange(nStep):
      fout.write('%15.5e'%data['e_r'][j]+'%15.5e'%data['s33_over_s11'][j]+'%15.5e'%data['e_v'][j]+'\n')
fout.close()

# control variables for PF.exe
fout = file('control_parameter.txt','w')
fout.write('%9i'%nStep     +' ! simulation step\n')
fout.write('%9i'%nSample   +' ! nsample in particle_filter.f90\n')
fout.write('%9i'%nObs      +' ! number of observation points (xyu) in particle_filter.f90\n')
fout.write('%9i'%len(names)+' ! number of parameters to be identified\n')
fout.close()

# co-variance matrix for PF.exe
fout = file('co-variance_matrix.txt','w')
covMatrix = np.zeros([nObs,nObs])
for i in xrange(nObs):
	covMatrix[i,i] = cov
	fout.write(' '.join(['%10.6f'%covMatrix[i,j] for j in xrange(nObs)]+['\n']))
fout.close()

# observation matrix for PF.exe
fout = file('obs_matrix.txt','w')
obsMatrix = np.identity(nObs)
for i in xrange(nObs):
	fout.write(' '.join(['%1i'%obsMatrix[i,j] for j in xrange(nObs)]+['\n']))
fout.close()

######################################
##  run the particle filter PF.exe  ##
######################################

# compile particle_filter.f90
if not path.isfile("./PF.exe"):
	system("gfortran -o PF.exe particle_filter.f90")
# run the particle filter executable
system("./PF.exe")

##################################
##  plot identified parameters  ##
##################################

ips = np.genfromtxt('IP.txt')
weight = np.genfromtxt('weight.txt')
params = np.genfromtxt('particle.txt')
# plot evolutions of identified parameters (weighted average) 
# and probability density function of identified parameters at selected steps
plotIPs(names,ips,nSample,weight,params)
